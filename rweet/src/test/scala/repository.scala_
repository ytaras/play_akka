package rweet

import org.specs2.mutable._
import org.specs2.specification.BeforeExample
import org.scalatest.concurrent._
import org.scalatest.concurrent.ScalaFutures._
import org.scalatest.time.{Span, Millis, Seconds}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

class RepositorySpec extends Specification with Scope {
  implicit val followUser = new Before {
    // TODO Here's duplicatoin
    implicit val patienceConfig =
      PatienceConfig(Span(1, Seconds), Span(15, Millis))
    def before =
      a.followUser(users(1), users(2)).futureValue
  }
  "The UserFollow API" should {
    "follow user" should  {
      "add user to followers" in
        a.followers(users(2)).futureValue === Set(users(2))
      "add user to followed" in
        a.followed(users(2)).futureValue === Set(users(1))
    }
  }

  "Send Rweet API" should {
    "send rweet" should {
      // TODO How to stack before's?
      implicit val sendRweet = new Before {
        implicit val patienceConfig =
          PatienceConfig(Span(1, Seconds), Span(15, Millis))

        def before = {
          val text = "Hello, @user4, we're talking about #stuff"
          a.sendRweet(a.Rweet.parse(text, users(2))).futureValue
        }
      }
      "send to author wall" in
        a.userWall(users(2)).map { _.length }.futureValue === 1
      "send to follower's wall" in
        a.userWall(users(1)).map { _.length }.futureValue === 1
      "send to mentioned user's wall" in
        a.userWall(users(4)).map { _.length }.futureValue === 1
      "send to hashTag's wall" in
        a.hashTags(a.HashTag("stuff")).map { _.length }.futureValue === 1
      "don't sent to anybody else" in {
        Future.sequence(
          // TODO Should be just drop 1 and 2 instead
          (2 to 10).map { users(_) }
            .map { a.userWall(_) }
        ).futureValue.should(allOf { l:List[a.Rweet] => l.isEmpty })
      }
      "don't send to other tags" in {
        a.hashTags(a.HashTag("otherStuff")).map { _.isEmpty }
          .futureValue === true
      }
    }

  }
}

trait Scope extends BeforeExample {
  object a extends api with model with persistence {
    def cleanDb = client.flushdb()
  }
  implicit val patienceConfig =
    PatienceConfig(Span(1, Seconds), Span(15, Millis))
  val users: Map[Int, a.User] =
    (1 to 10).map { i => (i, a.User(s"user${i}"))}.toMap
  def before = a.cleanDb.futureValue
}
